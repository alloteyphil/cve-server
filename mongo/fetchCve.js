import axios from "axios";
import Cve from "./models/cve.models.js";

// Function to fetch and store CVE data
export const fetchAndStoreCveData = async () => {
  try {
    // Define the NVD API URL
    const url = `https://services.nvd.nist.gov/rest/json/cves/2.0`;

    // Fetch data from the NVD API
    const response = await axios.get(url);

    // Extract the vulnerabilities array from the response
    const cveData = response.data.vulnerabilities;

    // Check if the data exists
    if (!cveData || cveData.length === 0) {
      console.log("No CVE data found.");
      return;
    }

    // Loop through each CVE item and save it to the database
    for (const cveItem of cveData) {
      const {
        id,
        sourceIdentifier,
        published,
        lastModified,
        vulnStatus,
        cveTags,
        cisaExploitAdd,
        cisaActionDue,
        cisaRequiredAction,
        cisaVulnerabilityName,
        descriptions,
        metrics,
        weaknesses,
        configurations,
        references,
      } = cveItem.cve || {};

      if (!id) {
        console.log("Skipping invalid CVE item:", cveItem);
        continue;
      }

      // Create a new CVE document based on the fetched data
      const cve = new Cve({
        id,
        sourceIdentifier: sourceIdentifier || "",
        published: published || "",
        lastModified: lastModified || "",
        vulnStatus: vulnStatus || "",
        cveTags: cveTags || [],
        cisaExploitAdd: cisaExploitAdd || "",
        cisaActionDue: cisaActionDue || "",
        cisaRequiredAction: cisaRequiredAction || "",
        cisaVulnerabilityName: cisaVulnerabilityName || "",
        descriptions:
          descriptions?.map((description) => ({
            lang: description.lang || "en",
            value: description.value || "",
          })) || [],
        metrics:
          metrics?.cvssMetricV2?.map((metric) => ({
            source: metric.source || "",
            type: metric.type || "",
            cvssData: metric.cvssData || {},
            baseSeverity: metric.baseSeverity || "",
            exploitabilityScore: metric.exploitabilityScore || 0,
            impactScore: metric.impactScore || 0,
            acInsufInfo: metric.acInsufInfo || false,
            obtainAllPrivilege: metric.obtainAllPrivilege || false,
            obtainUserPrivilege: metric.obtainUserPrivilege || false,
            obtainOtherPrivilege: metric.obtainOtherPrivilege || false,
            userInteractionRequired: metric.userInteractionRequired || false,
          })) || [],
        weaknesses:
          weaknesses?.map((weakness) => ({
            source: weakness.source || "",
            type: weakness.type || "",
            description:
              weakness.description?.map((desc) => ({
                lang: desc.lang || "en",
                value: desc.value || "",
              })) || [],
          })) || [],
        configurations:
          configurations?.map((configuration) => ({
            nodes:
              configuration.nodes?.map((node) => ({
                operator: node.operator || "",
                negate: node.negate || false,
                cpeMatch:
                  node.cpeMatch?.map((cpe) => ({
                    vulnerable: cpe.vulnerable || false,
                    criteria: cpe.criteria || "",
                    matchCriteriaId: cpe.matchCriteriaId || "",
                  })) || [],
              })) || [],
          })) || [],
        references:
          references?.map((reference) => ({
            url: reference.url || "",
            source: reference.source || "",
            tags: reference.tags || [],
          })) || [],
      });

      // Save the CVE document to the database
      await cve.save();
      console.log(`Saved CVE: ${cve.id}`);
    }
  } catch (error) {
    console.error("Error fetching and storing CVE data:", error.message);
    if (error.response) {
      console.error("API responded with an error:", error.response.data);
    } else if (error.request) {
      console.error("No response received from the API:", error.request);
    }
  }
};
