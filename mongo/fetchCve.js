import axios from "axios";
import Cve from "./models/cve.models.js";

// Function to fetch and store CVE data
export const fetchAndStoreCveData = async (cpeName) => {
  try {
    // Encode the CPE name to be used in the URL
    const url = `https://services.nvd.nist.gov/rest/json/cves/2.0?cpeName=${cpeName}`;

    // Fetch data from the NVD API
    const response = await axios.get(url);

    // Extract the vulnerabilities array from the response
    const cveData = response.data.vulnerabilities;

    // Check if the data exists
    if (!cveData || cveData.length === 0) {
      console.log("No CVE data found for the given CPE name.");
      return;
    }

    // Loop through each CVE item and save it to the database
    for (const cveItem of cveData) {
      // Check if necessary fields are present
      if (!cveItem.cve || !cveItem.cve.id) {
        console.log("Skipping invalid CVE item:", cveItem);
        continue;
      }

      // Create a new CVE document based on the fetched data
      const cve = new Cve({
        id: cveItem.cve.id,
        sourceIdentifier: cveItem.cve.sourceIdentifier || "",
        published: cveItem.cve.published || "",
        lastModified: cveItem.cve.lastModified || "",
        vulnStatus: cveItem.cve.vulnStatus || "",
        cveTags: cveItem.cve.cveTags || [],
        cisaExploitAdd: cveItem.cve.cisaExploitAdd || "",
        cisaActionDue: cveItem.cve.cisaActionDue || "",
        cisaRequiredAction: cveItem.cve.cisaRequiredAction || "",
        cisaVulnerabilityName: cveItem.cve.cisaVulnerabilityName || "",
        descriptions: cveItem.cve.descriptions
          ? cveItem.cve.descriptions.map((description) => ({
              lang: description.lang || "en",
              value: description.value || "",
            }))
          : [],
        metrics: cveItem.cve.metrics
          ? {
              cvssMetricV2: cveItem.cve.metrics.cvssMetricV2
                ? cveItem.cve.metrics.cvssMetricV2.map((metric) => ({
                    source: metric.source || "",
                    type: metric.type || "",
                    cvssData: metric.cvssData
                      ? {
                          version: metric.cvssData.version || "",
                          vectorString: metric.cvssData.vectorString || "",
                          accessVector: metric.cvssData.accessVector || "",
                          accessComplexity:
                            metric.cvssData.accessComplexity || "",
                          authentication: metric.cvssData.authentication || "",
                          confidentialityImpact:
                            metric.cvssData.confidentialityImpact || "",
                          integrityImpact:
                            metric.cvssData.integrityImpact || "",
                          availabilityImpact:
                            metric.cvssData.availabilityImpact || "",
                          baseScore: metric.cvssData.baseScore || 0,
                        }
                      : {},
                    baseSeverity: metric.baseSeverity || "",
                    exploitabilityScore: metric.exploitabilityScore || 0,
                    impactScore: metric.impactScore || 0,
                    acInsufInfo: metric.acInsufInfo || false,
                    obtainAllPrivilege: metric.obtainAllPrivilege || false,
                    obtainUserPrivilege: metric.obtainUserPrivilege || false,
                    obtainOtherPrivilege: metric.obtainOtherPrivilege || false,
                    userInteractionRequired:
                      metric.userInteractionRequired || false,
                  }))
                : [],
            }
          : {},
        weaknesses: cveItem.cve.weaknesses
          ? cveItem.cve.weaknesses.map((weakness) => ({
              source: weakness.source || "",
              type: weakness.type || "",
              description: weakness.description
                ? weakness.description.map((desc) => ({
                    lang: desc.lang || "en",
                    value: desc.value || "",
                  }))
                : [],
            }))
          : [],
        configurations: cveItem.cve.configurations
          ? cveItem.cve.configurations.map((configuration) => ({
              nodes: configuration.nodes
                ? configuration.nodes.map((node) => ({
                    operator: node.operator || "",
                    negate: node.negate || false,
                    cpeMatch: node.cpeMatch
                      ? node.cpeMatch.map((cpe) => ({
                          vulnerable: cpe.vulnerable || false,
                          criteria: cpe.criteria || "",
                          matchCriteriaId: cpe.matchCriteriaId || "",
                        }))
                      : [],
                  }))
                : [],
            }))
          : [],
        references: cveItem.cve.references
          ? cveItem.cve.references.map((reference) => ({
              url: reference.url || "",
              source: reference.source || "",
              tags: reference.tags || [],
            }))
          : [],
      });

      // Save the CVE document to the database
      await cve.save();
      console.log(`Saved CVE: ${cve.id}`);
    }
  } catch (error) {
    if (error.response) {
      console.error("API responded with an error:", error.response.data);
    } else if (error.request) {
      console.error("No response received from the API:", error.request);
    } else {
      console.error("Error setting up the request:", error.message);
    }
  }
};
